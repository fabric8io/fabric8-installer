# coding: utf-8
# -*- mode: ruby -*-
# vi: set ft=ruby :

# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!
VAGRANTFILE_API_VERSION = "2"

Vagrant.require_version ">= 1.7.4"

KUBERNETES_VERSION = ENV["KUBERNETES_VERSION"] || "1.3.0-alpha.2"

# for running the CD Pipeline we recommend at least 8000 for memory!
$vmMemory = Integer(ENV['FABRIC8_VM_MEMORY'] || 4096)
$sharedStorage = ENV['FABRIC8_SHARED_STORAGE'] || nil

$provisionScript = <<SCRIPT

export K8S_VERSION="v#{KUBERNETES_VERSION}"
export KUBECTL_VERSION="v#{KUBERNETES_VERSION}"
export KUBECTL_VERSION="v1.2.2"

# Modify Docker Config for an optional cache
FABRIC8_SHARED_STORAGE="#{$sharedStorage}"
if [ "x${FABRIC8_SHARED_STORAGE}" != "x" ]; then
  # Run a local cache container
  echo "Patching Docker daemon configuration to use a caching proxy..."
  sed -i 's_^\\\(ExecStart=/usr/bin/docker.*\\\)_\\1 --registry-mirror=http://localhost:5000_g' /etc/systemd/system/docker.service.d/override.conf
  systemctl daemon-reload
  systemctl restart docker

  mkdir -p /opt/shared/squid_cache
  if [ -e "/opt/shared/squid.tar" ]; then
    echo "Importing cached Squid Image..."
    docker load -i /opt/shared/squid.tar
  fi
  echo "Starting Squid Proxy container..."
  docker run --name squid -d --restart=always \
    -p 3128:3128 \
    -v /opt/shared/squid_cache:/var/cache/squid3 \
    pantinor/squid
  echo "Squid Web Cache started!"
  export SQUID_PROXY=' --proxy localhost:3128'
  if [ ! -e  "/opt/shared/squid.tar" ]; then
    echo "Storing Docker Registry Image on shared file system..."
    docker save -o /opt/shared/squid.tar pantinor/squid
  fi

  if [ -e "/opt/shared/hypercube/${K8S_VERSION}/hypercube.tar" ]; then
    echo "Importing cached Hypercube Image..."
    docker load -i /opt/shared/hypercube/${K8S_VERSION}/hypercube.tar
  fi

  mkdir -p /opt/shared/docker_registry_cache
  if [ -e "/opt/shared/docker_registry.tar" ]; then
    echo "Importing cached Docker Registry Image..."
    docker load -i /opt/shared/docker_registry.tar
  fi
  echo "Starting Docker Registry container..."
  docker run -p 5000:5000 -d --restart=always --name registry_cache   \
    -e REGISTRY_PROXY_REMOTEURL=http://registry-1.docker.io \
    -v /opt/shared/docker_registry_cache:/var/lib/registry \
    registry:2
  if [ ! -e  "/opt/shared/docker_registry.tar" ]; then
    echo "Storing Docker Registry Image on shared file system..."
    docker save -o /opt/shared/docker_registry.tar registry:2
  fi
fi

# Check memory
VM_MEMORY="#{$vmMemory}"
echo "=========================================================================="
echo "Using VM Memory of ${VM_MEMORY} MB"
if [ ${VM_MEMORY} -lt 8192 ]; then
  echo "NOTE: We recommend at least 8192 MB for running the 'cd-pipeline'."
  echo "      You can specify this with an environment variable FABRIC8_VM_MEMORY"
  echo "      E.g. when creating the VM with : 'FABRIC8_VM_MEMORY=8192 vagrant up'"
fi
echo "=========================================================================="

export MAX_RETRIES=10;
echo "Downloading Kubernetes release..."
while !  curl $SQUID_PROXY  --retry 999 --retry-max-time 0  -L -o /usr/bin/kubectl  http://storage.googleapis.com/kubernetes-release/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl
  do
    echo "Down. Retries left: $MAX_RETRIES" ;
    [ "$MAX_RETRIES" -gt "0" ] && export MAX_RETRIES=$((MAX_RETRIES - 1 )) || break;
    sleep 5s
  done ;
  set +x
if [ $? -ne 0 ]; then
    echo "Cannot download Kubernetes client from the internet. Check your connectivity and firewall or retry later."
    exit -1
fi
echo "Kubernetes release downloaded!"

chmod 755 /usr/bin/kubectl

cp /vagrant/bin/* /usr/bin
chmod 775 /usr/bin/recreate-kubernetes
chmod 775 /usr/bin/start-kubernetes

/usr/bin/start-kubernetes

if [ "x${FABRIC8_SHARED_STORAGE}" != "x" ]; then
  if [ ! -e  "/opt/shared/hypercube/${K8S_VERSION}/hypercube.tar" ]; then
    echo "Storing Docker Hypercube on shared file system"
    mkdir -p "/opt/shared/hypercube/${K8S_VERSION}"
    docker save -o /opt/shared/hypercube/${K8S_VERSION}/hypercube.tar "gcr.io/google_containers/hyperkube-amd64:${K8S_VERSION}"
  fi
fi

cat <<EOT

Testing kubernetes
==================
You can test kubernetes is running via:

  curl -L http://172.28.128.80:8080/version


To setup kubectl on your host:
=============================

kubectl config set-cluster local --server=http://172.28.128.80:8080
kubectl config set-context local
kubectl config use-context local
kubectl get pods


Now downloading gofabric8...

EOT


mkdir -p /tmp/gofabric8-download
cd /tmp/gofabric8-download
curl $SQUID_PROXY --retry 999 --retry-max-time 0 -sSL https://github.com/fabric8io/gofabric8/releases/download/v0.4.10/gofabric8-0.4.10-linux-amd64.tar.gz | tar xzv
chmod +x gofabric8
sudo mv gofabric8 /usr/bin

echo "Using gofabric8 to deploy fabric8 on kubernetes"

kubectl get pods

gofabric8 -s http://172.28.128.80:8080 deploy -y
gofabric8 -s http://172.28.128.80:8080 secrets -y
gofabric8 -s http://172.28.128.80:8080 volume -y --host-path="/vagrant/fabric8-data"

echo ""
echo "Waiting for the fabric8 console to start..."

until kubectl get pods -l project=console,provider=fabric8  | grep -m 1 "Running"; do sleep 1 ; done


cat <<EOT

fabric8 console
===============

You can now open the fabric8 console at:

  http://172.28.128.80:8080/api/v1/proxy/namespaces/default/services/fabric8/


Now to use the kubectl command line tool type:

kubectl config set-cluster local --server=http://172.28.128.80:8080
kubectl config set-context local
kubectl config use-context local
kubectl get pods

export KUBERNETES_MASTER=http://172.28.128.80:8080
export DOCKER_HOST=tcp://172.28.128.80:2375
unset DOCKER_TLS_VERIFY
unset DOCKER_CERT_PATH


If you ever find kubernetes apiserver or kubelet fails you can usually docker restart the container.

To recreate all the docker containers you can run:

  recreate-kubernetes

which will delete all docker containers and recreate kubernetes; which should recreate all the pods from kubernetes too.

EOT

SCRIPT

$windows = (/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) != nil

if $windows && Vagrant.has_plugin?("vagrant-hostmanager")
  raise 'Conflicting vagrant plugin detected - please uninstall & then try again: vagrant plugin uninstall vagrant-hostmanager'
end
$pluginToCheck = $windows ? "vagrant-hostmanager-fabric8" : "landrush"
unless Vagrant.has_plugin?($pluginToCheck)
  raise 'Please type this command then try again: vagrant plugin install ' + $pluginToCheck
end

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

  # Top level domain
  $tld = "k8s"

  # Landrush is used together with wildcard dns entries to map all
  # routes to the proper services
  if $windows
    config.hostmanager.enabled = true
    config.hostmanager.manage_host = true
    config.hostmanager.ignore_private_ip = false
    config.hostmanager.include_offline = true

    config.hostmanager.aliases = %w(fabric8.vagrant.k8s jenkins.vagrant.k8s gogs.vagrant.k8s nexus.vagrant.k8s hubot-web-hook.vagrant.k8s letschat.vagrant.k8s kibana.vagrant.k8s taiga.vagrant.k8s fabric8-forge.vagrant.k8s)
  else
    config.landrush.enabled = true
    config.landrush.tld = $tld
    config.landrush.host_ip_address = '172.28.128.80'
  end

  config.vm.box = "jimmidyson/centos-7.1"
  config.vm.box_version = "= 1.3.1"

  config.vm.network "private_network", ip: "172.28.128.80"

  config.vm.hostname = "vagrant." + $tld

  config.vm.provider "virtualbox" do |v|
    v.memory = $vmMemory
    v.cpus = 2
    v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
  end

  config.vm.provider :libvirt do |v, override|
    v.cpus = 2
    v.memory = $vmMemory

    override.vm.allowed_synced_folder_types = [:nfs, :rsync]
  end

  config.vm.provision "shell", inline: $provisionScript, keep_color: true

  if !$sharedStorage.nil?
    config.vm.synced_folder $sharedStorage, "/opt/shared"
  end

end
