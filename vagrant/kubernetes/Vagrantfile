# coding: utf-8
# -*- mode: ruby -*-
# vi: set ft=ruby :

# Vagrantfile API/syntax version. Don't touch unless you know what you're doing!
VAGRANTFILE_API_VERSION = "2"

Vagrant.require_version ">= 1.7.4"

KUBERNETES_VERSION = ENV["KUBERNETES_VERSION"] || "1.3.0-alpha.2"

$provisionScript = <<SCRIPT

export K8S_VERSION="v#{KUBERNETES_VERSION}"
export KUBECTL_VERSION="v#{KUBERNETES_VERSION}"
export KUBECTL_VERSION="v1.2.2"

cat <<EOT > /usr/bin/recreate-kubernetes
#!/bin/sh
echo "Recreating kubernetes..."

echo "Stopping all docker containers"
docker stop \$(docker ps -a -q)

echo "Removing all docker containers"
docker rm -f \$(docker ps -a -q)

echo "Starting Kuberentes"
/usr/bin/start-kubernetes
EOT

chmod 775 /usr/bin/recreate-kubernetes

cat <<EOT > /usr/bin/start-kubernetes
#!/bin/sh
echo "Running Kubernetes version: ${K8S_VERSION}"
docker run \
    --volume=/:/rootfs:ro \
    --volume=/sys:/sys:ro \
    --volume=/var/lib/docker/:/var/lib/docker:rw \
    --volume=/var/lib/kubelet/:/var/lib/kubelet:rw \
    --volume=/var/run:/var/run:rw \
    --net=host \
    --pid=host \
    --privileged=true \
    --name=kubelet \
    -d \
    gcr.io/google_containers/hyperkube-amd64:${K8S_VERSION} \
    /hyperkube kubelet \
        --containerized \
        --hostname-override="172.28.128.80" \
        --address="0.0.0.0" \
        --api-servers=http://172.28.128.80:8080 \
        --config=/etc/kubernetes/manifests \
        --cluster-dns=10.0.0.10 \
        --cluster-domain=cluster.local \
        --allow-privileged=true --v=2

kubectl config set-cluster default --server=http://localhost:8080
kubectl config set-context default --cluster=cluster
kubectl config use-context default

until kubectl get pods 2>/dev/null >/dev/null;
do
  sleep 1
done

docker exec kubelet sed -i 's/--insecure-bind-address=127.0.0.1/--insecure-bind-address=0.0.0.0/' /etc/kubernetes/manifests/master.json

until kubectl get pods --server=http://172.28.128.80:8080 2>/dev/null >/dev/null;
do
  sleep 1
done

kubectl create namespace kube-system

curl -LO http://kubernetes.io/docs/getting-started-guides/docker-multinode/skydns.yaml.in

export DNS_REPLICAS=1
export DNS_DOMAIN=cluster.local
export DNS_SERVER_IP=10.0.0.10

sed -e "s/{{ pillar\\['dns_replicas'\\] }}/${DNS_REPLICAS}/g;s/{{ pillar\\['dns_domain'\\] }}/${DNS_DOMAIN}/g;s/{{ pillar\\['dns_server'\\] }}/${DNS_SERVER_IP}/g" skydns.yaml.in > ./skydns.yaml
kubectl apply -f ./skydns.yaml

EOT

chmod 775 /usr/bin/start-kubernetes

curl -Lo /usr/bin/kubectl http://storage.googleapis.com/kubernetes-release/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl
chmod 755 /usr/bin/kubectl

/usr/bin/start-kubernetes

cat <<EOT

Testing kubernetes
==================
You can test kubernetes is running via:

  curl -L http://172.28.128.80:8080/version


To setup kubectl on your host:
=============================

kubectl config set-cluster local --server=http://172.28.128.80:8080
kubectl config set-context local
kubectl config use-context local
kubectl get pods


Now downloading gofabric8...

EOT


mkdir -p /tmp/gofabric8-download
cd /tmp/gofabric8-download
curl --retry 999 --retry-max-time 0 -sSL https://github.com/fabric8io/gofabric8/releases/download/v0.4.10/gofabric8-0.4.10-linux-amd64.tar.gz | tar xzv
chmod +x gofabric8
sudo mv gofabric8 /usr/bin

echo "Using gofabric8 to deploy fabric8 on kubernetes"

kubectl get pods

gofabric8 -s http://172.28.128.80:8080 deploy -y
gofabric8 -s http://172.28.128.80:8080 secrets -y
gofabric8 -s http://172.28.128.80:8080 volume -y --host-path="/vagrant/fabric8-data"

echo ""
echo "Waiting for the fabric8 console to start..."

until kubectl get pods -l project=console,provider=fabric8  | grep -m 1 "Running"; do sleep 1 ; done


cat <<EOT

fabric8 console
===============

You can now open the fabric8 console at:

  http://172.28.128.80:8080/api/v1/proxy/namespaces/default/services/fabric8/


Now to use the kubectl command line tool type:

kubectl config set-cluster local --server=http://172.28.128.80:8080
kubectl config set-context local
kubectl config use-context local
kubectl get pods

export KUBERNETES_MASTER=http://172.28.128.80:8080
export DOCKER_HOST=tcp://172.28.128.80:2375
unset DOCKER_TLS_VERIFY
unset DOCKER_CERT_PATH

EOT

SCRIPT

$windows = (/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) != nil

if $windows && Vagrant.has_plugin?("vagrant-hostmanager")
  raise 'Conflicting vagrant plugin detected - please uninstall & then try again: vagrant plugin uninstall vagrant-hostmanager'
end
$pluginToCheck = $windows ? "vagrant-hostmanager-fabric8" : "landrush"
unless Vagrant.has_plugin?($pluginToCheck)
  raise 'Please type this command then try again: vagrant plugin install ' + $pluginToCheck
end

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

  # Top level domain
  $tld = "k8s"

  # Landrush is used together with wildcard dns entries to map all
  # routes to the proper services
  if $windows
    config.hostmanager.enabled = true
    config.hostmanager.manage_host = true
    config.hostmanager.ignore_private_ip = false
    config.hostmanager.include_offline = true

    config.hostmanager.aliases = %w(fabric8.vagrant.k8s jenkins.vagrant.k8s gogs.vagrant.k8s nexus.vagrant.k8s hubot-web-hook.vagrant.k8s letschat.vagrant.k8s kibana.vagrant.k8s taiga.vagrant.k8s fabric8-forge.vagrant.k8s)
  else
    config.landrush.enabled = true
    config.landrush.tld = $tld
    config.landrush.host_ip_address = '172.28.128.80'
  end

  config.vm.box = "jimmidyson/centos-7.1"
  config.vm.box_version = "= 1.3.1"

  config.vm.network "private_network", ip: "172.28.128.80"

  config.vm.hostname = "vagrant." + $tld

  config.vm.provider "virtualbox" do |v|
    v.memory = 4096
    v.cpus = 2
    v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
  end

  config.vm.provider :libvirt do |v, override|
    v.cpus = 2
    v.memory = 4096

    override.vm.allowed_synced_folder_types = [:nfs, :rsync]
  end

  config.vm.provision "shell", inline: $provisionScript, keep_color: true

end
